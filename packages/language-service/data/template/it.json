{
  "version": 1.1,
  "tags": [
    {
      "name": "Transition",
      "description": {
        "kind": "markdown",
        "value": "\nFornisce un'animazione di transizione a un **solo** elemento o componente.\n\n- **Props**\n\n  ```ts\n  interface TransitionProps {\n    /**\n     * Usato per generare automaticamente classi CSS per le transizioni.\n     * Per esempio `name: 'fade'` verrà automaticamente espanso in `.fade-enter`,\n     * `.fade-enter-active`, etc.\n     */\n    name?: string\n    /**\n     * Definisce se applicare le classi di transizione CSS.\n     * Predefinito: true\n     */\n    css?: boolean\n    /**\n     * Specifica il tipo di evento di transizione da attendere\n     * per determinare la tempistica della fine della transizione.\n     * Il comportamento predefinito rileva automaticamente il tipo che ha\n     * la durata maggiore.\n     */\n    type?: 'transition' | 'animation'\n    /**\n     * Specifica esplicitamente la durata della transizione.\n     * Il comportamento predefinito è di attendere il primo evento\n     * `transitionend` o `animationend` nel root dell'elemento transition.\n     */\n    duration?: number | { enter: number; leave: number }\n    /**\n     * Controlla la sequenza temporale delle transizioni di uscita/entrata.\n     * Il comportamento predefinito è simultaneo\n     */\n    mode?: 'in-out' | 'out-in' | 'default'\n    /**\n     * Definisce se applicare la transizione al rendering iniziale.\n     * Predefinito: false\n     */\n    appear?: boolean\n\n    /**\n     * Props per personalizzare le classi di transizione.\n     * Usa il kebab-case nei template, per esempio enter-from-class=\"xxx\"\n     */\n    enterFromClass?: string\n    enterActiveClass?: string\n    enterToClass?: string\n    appearFromClass?: string\n    appearActiveClass?: string\n    appearToClass?: string\n    leaveFromClass?: string\n    leaveActiveClass?: string\n    leaveToClass?: string\n  }\n  ```\n\n- **Eventi**\n\n  - `@before-enter`\n  - `@before-leave`\n  - `@enter`\n  - `@leave`\n  - `@appear`\n  - `@after-enter`\n  - `@after-leave`\n  - `@after-appear`\n  - `@enter-cancelled`\n  - `@leave-cancelled` (solo `v-show`)\n  - `@appear-cancelled`\n\n- **Esempio**\n\n  Elemento semplice:\n\n  ```html\n  <Transition>\n    <div v-if=\"ok\">contenuto attivato</div>\n  </Transition>\n  ```\n\n  Forzare una transizione cambiando l'attributo `key`:\n\n  ```html\n  <Transition>\n    <div :key=\"text\">{{ text }}</div>\n  </Transition>\n  ```\n\n  Componente dinamico, con modalità di transizione + animazione in entrata:\n\n  ```html\n  <Transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </Transition>\n  ```\n\n  Ascolto eventi transizione:\n\n  ```html\n  <Transition @after-enter=\"onTransitionComplete\">\n    <div v-show=\"ok\">toggled content</div>\n  </Transition>\n  ```\n\n- **Vedi anche** [Guida `<Transition>`](https://it.vuejs.org/guide/built-ins/transition.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#transition"
    },
    {
      "name": "TransitionGroup",
      "description": {
        "kind": "markdown",
        "value": "\nFornisce effetti di transizione per elementi **multipli** o componenti in un elenco.\n\n- **Props**\n\n  `<TransitionGroup>` accetta le stesse props di `<Transition>` tranne `mode`, più due prop aggiuntive:\n\n  ```ts\n  interface TransitionGroupProps extends Omit<TransitionProps, 'mode'> {\n    /**\n     * Se non definito, renderizza come un fragment\n     */\n    tag?: string\n    /**\n     * Per personalizzare la classe CSS applicata durante la transizione.\n     * Usa il kebab-case nel template, per esempio move-class=\"xxx\"\n     */\n    moveClass?: string\n  }\n  ```\n\n- **Eventi**\n\n  `<TransitionGroup>` emette gli stessi eventi di `<Transition>`.\n\n- **Dettagli**\n\n  Di default, `<TransitionGroup>` non renderizza un elemento DOM wrapper, ma uno può essere definito attraverso la prop `tag`.\n\n  Nota che ogni figlio in `<transition-group>` deve avere una [**chiave univoca**](https://it.vuejs.org/guide/essentials/list.html#maintaining-state-with-key) per l'animazione per funzionare correttamente.\n\n  `<TransitionGroup>` supporta le transizioni tramite trasformazione CSS. Quando la posizione di un figlio nello schermo cambia dopo un aggiornamento, gli verrà applicata una classe CSS di movimento (generata automaticamente dall'attributo `name` o configurato con la prop `move-class`). Se la proprietà CSS `transform` è \"transition-able\" quando la classe di movimento è applicata, l'elemento verrà animato fluidamente alla sua destinazione usando la [tecnica FLIP](https://aerotwist.com/blog/flip-your-animations/).\n\n- **Esempio**\n\n  ```html\n  <TransitionGroup tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </TransitionGroup>\n  ```\n\n- **Vedi anche** [Guida - TransitionGroup](https://it.vuejs.org/guide/built-ins/transition-group.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#transitiongroup"
    },
    {
      "name": "KeepAlive",
      "description": {
        "kind": "markdown",
        "value": "\nMemorizza nella cache i componenti attivati/disattivati ​​dinamicamente racchiusi all'interno.\n\n- **Props**\n\n  ```ts\n  interface KeepAliveProps {\n    /**\n     * Se specificata, solo i componenti con gli stessi nomi corrispondenti a \n     * `include` saranno memorizzati nella cache.\n     */\n    include?: MatchPattern\n    /**\n     * Qualsiasi componente con un nome corrispondente a `exclude`\n     * non verrà memorizzato nella cache.\n     */\n    exclude?: MatchPattern\n    /**\n     * Il numero massimo di istanze del componente da memorizzare nella cache.\n     */\n    max?: number | string\n  }\n\n  type MatchPattern = string | RegExp | (string | RegExp)[]\n  ```\n\n- **Dettagli**\n\n  Quando racchiuso in un componente dinamico, `<KeepAlive>` memorizza nella cache le istanze dei componenti inattivi senza distruggerle.\n\n  Ci può essere solo un'istanza di un componente come figlio diretto di `<KeepAlive>` in qualsiasi momento.\n\n  Quando un componente è azionato dentro `<KeepAlive>`, i suoi lifecycle hooks `activated` e `deactivated` verranno richiamati di conseguenza, offrendo un alternativa a `mounted` e `unmounted`, che non sono chiamati. Questo si applica ai figli diretti di `<KeepAlive>` e anche a tutti i suoi discendenti.\n\n- **Esempio**\n\n  Utilizzo Base:\n\n  ```html\n  <KeepAlive>\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n  Quando usato con `v-if` / `v-else`, ci deve essere solo un componente renderizzato alla volta:\n\n  ```html\n  <KeepAlive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </KeepAlive>\n  ```\n  Usato insieme a `<Transition>`:\n\n  ```html\n  <Transition>\n    <KeepAlive>\n      <component :is=\"view\"></component>\n    </KeepAlive>\n  </Transition>\n  ```\n  Usando `include` / `exclude`: \n\n  ```html\n  <!-- stringa con delimitatore virgola -->\n  <KeepAlive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- regex (usando `v-bind`) -->\n  <KeepAlive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- Array (usando `v-bind`) -->\n  <KeepAlive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n  Utilizzo con `max`:\n\n  ```html\n  <KeepAlive :max=\"10\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n- **Vedi anche** [Guida - KeepAlive](https://it.vuejs.org/guide/built-ins/keep-alive.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#keepalive"
    },
    {
      "name": "Teleport",
      "description": {
        "kind": "markdown",
        "value": "\nRenderizza il contenuto dello slot in un' altra parte del DOM.\n\n- **Props**\n\n  ```ts\n  interface TeleportProps {\n    /**\n     * Obbligatoria. Specifica il container di destinazione.\n     * Può essere sia un selettore o un elemento reale.\n     */\n    to: string | HTMLElement\n    /**\n     * Quando `true`, il contenuto resterà nella posizione\n     * originale invece di essere spostato nel container di destinazione.\n     * Può essere cambiato dinamicamente.\n     */\n    disabled?: boolean\n  }\n  ```\n\n- **Esempio**\n\n  Specificando un container di destinazione\n\n  ```html\n  <teleport to=\"#some-id\" />\n  <teleport to=\".some-class\" />\n  <teleport to=\"[data-teleport]\" />\n  ```\n  Disabilitazione condizionale:\n\n  ```html\n  <teleport to=\"#popup\" :disabled=\"displayVideoInline\">\n    <video src=\"./my-movie.mp4\">\n  </teleport>\n  ```\n\n- **Vedi anche** [Guida - Teleport](https://it.vuejs.org/guide/built-ins/teleport.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#teleport"
    },
    {
      "name": "Suspense",
      "description": {
        "kind": "markdown",
        "value": "\nUsato per orchestrare dipendenze asincrone annidate in un albero di componenti.\n\n- **Props**\n\n  ```ts\n  interface SuspenseProps {\n    timeout?: string | number\n  }\n  ```\n\n- **Eventi**\n\n  - `@resolve`\n  - `@pending`\n  - `@fallback`\n\n- **Dettagli**\n\n  `<Suspense>` accetta due slots: lo slot di `#default` e lo slot `#fallback`. Mostrerà il contenuto dello slot di fallback mentre renderizza lo slot default in memoria.\n\n  Se incontra dipendenze asincrone ([Componente asincrono](https://it.vuejs.org/guide/components/async.html) e componenti con [`async setup()`](https://it.vuejs.org/guide/built-ins/suspense.html#async-setup)) mentre renderizza lo slot di default, aspetterà fino a quando tutti sono risolti prima di visualizzare lo slot di default.\n\n- **Vedi anche** [Guida - Suspense](https://it.vuejs.org/guide/built-ins/suspense.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#suspense"
    },
    {
      "name": "component",
      "description": {
        "kind": "markdown",
        "value": "\nA \"meta component\" for rendering dynamic components or elements.\n\n- **Props**\n\n  ```ts\n  interface DynamicComponentProps {\n    is: string | Component\n  }\n  ```\n\n- **Details**\n\n  The actual component to render is determined by the `is` prop.\n\n  - When `is` is a string, it could be either an HTML tag name or a component's registered name.\n\n  - Alternatively, `is` can also be directly bound to the definition of a component.\n\n- **Example**\n\n  Rendering components by registered name (Options API):\n\n  ```vue\n  <script>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n\n  export default {\n    components: { Foo, Bar },\n    data() {\n      return {\n        view: 'Foo'\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"view\" />\n  </template>\n  ```\n\n  Rendering components by definition (Composition API with `<script setup>`):\n\n  ```vue\n  <script setup>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n  </script>\n\n  <template>\n    <component :is=\"Math.random() > 0.5 ? Foo : Bar\" />\n  </template>\n  ```\n\n  Rendering HTML elements:\n\n  ```html\n  <component :is=\"href ? 'a' : 'span'\"></component>\n  ```\n\n  The [built-in components](./built-in-components) can all be passed to `is`, but you must register them if you want to pass them by name. For example:\n\n  ```vue\n  <script>\n  import { Transition, TransitionGroup } from 'vue'\n\n  export default {\n    components: {\n      Transition,\n      TransitionGroup\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"isGroup ? 'TransitionGroup' : 'Transition'\">\n      ...\n    </component>\n  </template>\n  ```\n\n  Registration is not required if you pass the component itself to `is` rather than its name, e.g. in `<script setup>`.\n\n  If `v-model` is used on a `<component>` tag, the template compiler will expand it to a `modelValue` prop and `update:modelValue` event listener, much like it would for any other component. However, this won't be compatible with native HTML elements, such as `<input>` or `<select>`. As a result, using `v-model` with a dynamically created native element won't work:\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const tag = ref('input')\n  const username = ref('')\n  </script>\n\n  <template>\n    <!-- This won't work as 'input' is a native HTML element -->\n    <component :is=\"tag\" v-model=\"username\" />\n  </template>\n  ```\n\n  In practice, this edge case isn't common as native form fields are typically wrapped in components in real applications. If you do need to use a native element directly then you can split the `v-model` into an attribute and event manually.\n\n- **See also** [Dynamic Components](https://it.vuejs.org/guide/essentials/component-basics.html#dynamic-components)\n"
      },
      "attributes": [],
      "references": "api/built-in-special-elements.html#component"
    },
    {
      "name": "slot",
      "description": {
        "kind": "markdown",
        "value": "\nDenotes slot content outlets in templates.\n\n- **Props**\n\n  ```ts\n  interface SlotProps {\n    /**\n     * Any props passed to <slot> to passed as arguments\n     * for scoped slots\n     */\n    [key: string]: any\n    /**\n     * Reserved for specifying slot name.\n     */\n    name?: string\n  }\n  ```\n\n- **Details**\n\n  The `<slot>` element can use the `name` attribute to specify a slot name. When no `name` is specified, it will render the default slot. Additional attributes passed to the slot element will be passed as slot props to the scoped slot defined in the parent.\n\n  The element itself will be replaced by its matched slot content.\n\n  `<slot>` elements in Vue templates are compiled into JavaScript, so they are not to be confused with [native `<slot>` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot).\n\n- **See also** [Component - Slots](https://it.vuejs.org/guide/components/slots.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-special-elements.html#slot"
    },
    {
      "name": "template",
      "description": {
        "kind": "markdown",
        "value": "\nThe `<template>` tag is used as a placeholder when we want to use a built-in directive without rendering an element in the DOM.\n\n- **Details**\n\n  The special handling for `<template>` is only triggered if it is used with one of these directives:\n\n  - `v-if`, `v-else-if`, or `v-else`\n  - `v-for`\n  - `v-slot`\n\n  If none of those directives are present then it will be rendered as a [native `<template>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template) instead.\n\n  A `<template>` with a `v-for` can also have a [`key` attribute](https://it.vuejs.org/api/built-in-special-attributes.html#key). All other attributes and directives will be discarded, as they aren't meaningful without a corresponding element.\n\n  Single-file components use a [top-level `<template>` tag](https://it.vuejs.org/api/sfc-spec.html#language-blocks) to wrap the entire template. That usage is separate from the use of `<template>` described above. That top-level tag is not part of the template itself and doesn't support template syntax, such as directives.\n\n- **See also**\n  - [Guide - `v-if` on `<template>`](https://it.vuejs.org/guide/essentials/conditional.html#v-if-on-template)\n  - [Guide - `v-for` on `<template>`](https://it.vuejs.org/guide/essentials/list.html#v-for-on-template)\n  - [Guide - Named slots](https://it.vuejs.org/guide/components/slots.html#named-slots)\n"
      },
      "attributes": [],
      "references": "api/built-in-special-elements.html#template"
    }
  ],
  "globalAttributes": [
    {
      "name": "v-text",
      "description": {
        "kind": "markdown",
        "value": "Update the element's text content.\n\n- **Expects:** `string`\n\n- **Details**\n\n  `v-text` works by setting the element's [textContent](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) property, so it will overwrite any existing content inside the element. If you need to update the part of `textContent`, you should use [mustache interpolations](https://it.vuejs.org/guide/essentials/template-syntax.html#text-interpolation) instead.\n\n- **Example**\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- same as -->\n  <span>{{msg}}</span>\n  ```\n\n- **See also** [Template Syntax - Text Interpolation](https://it.vuejs.org/guide/essentials/template-syntax.html#text-interpolation)"
      },
      "references": "api/built-in-directives.html#v-text"
    },
    {
      "name": "v-html",
      "description": {
        "kind": "markdown",
        "value": "Update the element's [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML).\n\n- **Expects:** `string`\n\n- **Details**\n\n  Contents of `v-html` are inserted as plain HTML - Vue template syntax will not be processed. If you find yourself trying to compose templates using `v-html`, try to rethink the solution by using components instead.\n\n  ::: warning Security Note\n  Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS attacks](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use `v-html` on trusted content and **never** on user-provided content.\n  :::\n\n  In [Single-File Components](https://it.vuejs.org/guide/scaling-up/sfc.html), `scoped` styles will not apply to content inside `v-html`, because that HTML is not processed by Vue's template compiler. If you want to target `v-html` content with scoped CSS, you can instead use [CSS modules](./sfc-css-features#css-modules) or an additional, global `<style>` element with a manual scoping strategy such as BEM.\n\n- **Example**\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n\n- **See also** [Template Syntax - Raw HTML](https://it.vuejs.org/guide/essentials/template-syntax.html#raw-html)"
      },
      "references": "api/built-in-directives.html#v-html"
    },
    {
      "name": "v-show",
      "description": {
        "kind": "markdown",
        "value": "Toggle the element's visibility based on the truthy-ness of the expression value.\n\n- **Expects:** `any`\n\n- **Details**\n\n  `v-show` works by setting the `display` CSS property via inline styles, and will try to respect the initial `display` value when the element is visible. It also triggers transitions when its condition changes.\n\n- **See also** [Conditional Rendering - v-show](https://it.vuejs.org/guide/essentials/conditional.html#v-show)"
      },
      "references": "api/built-in-directives.html#v-show"
    },
    {
      "name": "v-if",
      "description": {
        "kind": "markdown",
        "value": "Conditionally render an element or a template fragment based on the truthy-ness of the expression value.\n\n- **Expects:** `any`\n\n- **Details**\n\n  When a `v-if` element is toggled, the element and its contained directives / components are destroyed and re-constructed. If the initial condition is falsy, then the inner content won't be rendered at all.\n\n  Can be used on `<template>` to denote a conditional block containing only text or multiple elements.\n\n  This directive triggers transitions when its condition changes.\n\n  When used together, `v-if` has a higher priority than `v-for`. We don't recommend using these two directives together on one element — see the [list rendering guide](https://it.vuejs.org/guide/essentials/list.html#v-for-with-v-if) for details.\n\n- **See also** [Conditional Rendering - v-if](https://it.vuejs.org/guide/essentials/conditional.html#v-if)"
      },
      "references": "api/built-in-directives.html#v-if"
    },
    {
      "name": "v-else",
      "valueSet": "v",
      "description": {
        "kind": "markdown",
        "value": "Denote the \"else block\" for `v-if` or a `v-if` / `v-else-if` chain.\n\n- **Does not expect expression**\n\n- **Details**\n\n  - Restriction: previous sibling element must have `v-if` or `v-else-if`.\n\n  - Can be used on `<template>` to denote a conditional block containing only text or multiple elements.\n\n- **Example**\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **See also** [Conditional Rendering - v-else](https://it.vuejs.org/guide/essentials/conditional.html#v-else)"
      },
      "references": "api/built-in-directives.html#v-else"
    },
    {
      "name": "v-else-if",
      "description": {
        "kind": "markdown",
        "value": "Denote the \"else if block\" for `v-if`. Can be chained.\n\n- **Expects:** `any`\n\n- **Details**\n\n  - Restriction: previous sibling element must have `v-if` or `v-else-if`.\n\n  - Can be used on `<template>` to denote a conditional block containing only text or multiple elements.\n\n- **Example**\n\n  ```html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **See also** [Conditional Rendering - v-else-if](https://it.vuejs.org/guide/essentials/conditional.html#v-else-if)"
      },
      "references": "api/built-in-directives.html#v-else-if"
    },
    {
      "name": "v-for",
      "description": {
        "kind": "markdown",
        "value": "Render the element or template block multiple times based on the source data.\n\n- **Expects:** `Array | Object | number | string | Iterable`\n\n- **Details**\n\n  The directive's value must use the special syntax `alias in expression` to provide an alias for the current element being iterated on:\n\n  ```html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  Alternatively, you can also specify an alias for the index (or the key if used on an Object):\n\n  ```html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(value, key) in object\"></div>\n  <div v-for=\"(value, name, index) in object\"></div>\n  ```\n\n  The default behavior of `v-for` will try to patch the elements in-place without moving them. To force it to reorder elements, you should provide an ordering hint with the `key` special attribute:\n\n  ```html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  `v-for` can also work on values that implement the [Iterable Protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol), including native `Map` and `Set`.\n\n- **See also**\n  - [List Rendering](https://it.vuejs.org/guide/essentials/list.html)"
      },
      "references": "api/built-in-directives.html#v-for"
    },
    {
      "name": "v-on",
      "description": {
        "kind": "markdown",
        "value": "Attach an event listener to the element.\n\n- **Shorthand:** `@`\n\n- **Expects:** `Function | Inline Statement | Object (without argument)`\n\n- **Argument:** `event` (optional if using Object syntax)\n\n- **Modifiers**\n\n  - `.stop` - call `event.stopPropagation()`.\n  - `.prevent` - call `event.preventDefault()`.\n  - `.capture` - add event listener in capture mode.\n  - `.self` - only trigger handler if event was dispatched from this element.\n  - `.{keyAlias}` - only trigger handler on certain keys.\n  - `.once` - trigger handler at most once.\n  - `.left` - only trigger handler for left button mouse events.\n  - `.right` - only trigger handler for right button mouse events.\n  - `.middle` - only trigger handler for middle button mouse events.\n  - `.passive` - attaches a DOM event with `{ passive: true }`.\n\n- **Details**\n\n  The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.\n\n  When used on a normal element, it listens to [**native DOM events**](https://developer.mozilla.org/en-US/docs/Web/Events) only. When used on a custom element component, it listens to **custom events** emitted on that child component.\n\n  When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special `$event` property: `v-on:click=\"handle('ok', $event)\"`.\n\n  `v-on` also supports binding to an object of event / listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.\n\n- **Example**\n\n  ```html\n  <!-- method handler -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- dynamic event -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- inline statement -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- shorthand -->\n  <button @click=\"doThis\"></button>\n\n  <!-- shorthand dynamic event -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- stop propagation -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- prevent default -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- prevent default without expression -->\n  <form @submit.prevent></form>\n\n  <!-- chain modifiers -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- key modifier using keyAlias -->\n  <input @keyup.enter=\"onEnter\" />\n\n  <!-- the click event will be triggered at most once -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- object syntax -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\n  ```html\n  <MyComponent @my-event=\"handleThis\" />\n\n  <!-- inline statement -->\n  <MyComponent @my-event=\"handleThis(123, $event)\" />\n  ```\n\n- **See also**\n  - [Event Handling](https://it.vuejs.org/guide/essentials/event-handling.html)\n  - [Components - Custom Events](https://it.vuejs.org/guide/essentials/component-basics.html#listening-to-events)"
      },
      "references": "api/built-in-directives.html#v-on"
    },
    {
      "name": "v-bind",
      "description": {
        "kind": "markdown",
        "value": "Dynamically bind one or more attributes, or a component prop to an expression.\n\n- **Shorthand:** `:` or `.` (when using `.prop` modifier)\n\n- **Expects:** `any (with argument) | Object (without argument)`\n\n- **Argument:** `attrOrProp (optional)`\n\n- **Modifiers**\n\n  - `.camel` - transform the kebab-case attribute name into camelCase.\n  - `.prop` - force a binding to be set as a DOM property. <sup class=\"vt-badge\">3.2+</sup>\n  - `.attr` - force a binding to be set as a DOM attribute. <sup class=\"vt-badge\">3.2+</sup>\n\n- **Usage**\n\n  When used to bind the `class` or `style` attribute, `v-bind` supports additional value types such as Array or Objects. See linked guide section below for more details.\n\n  When setting a binding on an element, Vue by default checks whether the element has the key defined as a property using an `in` operator check. If the property is defined, Vue will set the value as a DOM property instead of an attribute. This should work in most cases, but you can override this behavior by explicitly using `.prop` or `.attr` modifiers. This is sometimes necessary, especially when [working with custom elements](https://it.vuejs.org/guide/extras/web-components.html#passing-dom-properties).\n\n  When used for component prop binding, the prop must be properly declared in the child component.\n\n  When used without an argument, can be used to bind an object containing attribute name-value pairs.\n\n- **Example**\n\n  ```html\n  <!-- bind an attribute -->\n  <img v-bind:src=\"imageSrc\" />\n\n  <!-- dynamic attribute name -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- shorthand -->\n  <img :src=\"imageSrc\" />\n\n  <!-- shorthand dynamic attribute name -->\n  <button :[key]=\"value\"></button>\n\n  <!-- with inline string concatenation -->\n  <img :src=\"'/path/to/images/' + fileName\" />\n\n  <!-- class binding -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\"></div>\n\n  <!-- style binding -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- binding an object of attributes -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- prop binding. \"prop\" must be declared in the child component. -->\n  <MyComponent :prop=\"someThing\" />\n\n  <!-- pass down parent props in common with a child component -->\n  <MyComponent v-bind=\"$props\" />\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  The `.prop` modifier also has a dedicated shorthand, `.`:\n\n  ```html\n  <div :someProperty.prop=\"someObject\"></div>\n\n  <!-- equivalent to -->\n  <div .someProperty=\"someObject\"></div>\n  ```\n\n  The `.camel` modifier allows camelizing a `v-bind` attribute name when using in-DOM templates, e.g. the SVG `viewBox` attribute:\n\n  ```html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  `.camel` is not needed if you are using string templates, or pre-compiling the template with a build step.\n\n- **See also**\n  - [Class and Style Bindings](https://it.vuejs.org/guide/essentials/class-and-style.html)\n  - [Components - Prop Passing Details](https://it.vuejs.org/guide/components/props.html#prop-passing-details)"
      },
      "references": "api/built-in-directives.html#v-bind"
    },
    {
      "name": "v-model",
      "description": {
        "kind": "markdown",
        "value": "Create a two-way binding on a form input element or a component.\n\n- **Expects:** varies based on value of form inputs element or output of components\n\n- **Limited to:**\n\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **Modifiers**\n\n  - [`.lazy`](https://it.vuejs.org/guide/essentials/forms.html#lazy) - listen to `change` events instead of `input`\n  - [`.number`](https://it.vuejs.org/guide/essentials/forms.html#number) - cast valid input string to numbers\n  - [`.trim`](https://it.vuejs.org/guide/essentials/forms.html#trim) - trim input\n\n- **See also**\n\n  - [Form Input Bindings](https://it.vuejs.org/guide/essentials/forms.html)\n  - [Component Events - Usage with `v-model`](https://it.vuejs.org/guide/components/v-model.html)"
      },
      "references": "api/built-in-directives.html#v-model"
    },
    {
      "name": "v-slot",
      "description": {
        "kind": "markdown",
        "value": "Denote named slots or scoped slots that expect to receive props.\n\n- **Shorthand:** `#`\n\n- **Expects:** JavaScript expression that is valid in a function argument position, including support for destructuring. Optional - only needed if expecting props to be passed to the slot.\n\n- **Argument:** slot name (optional, defaults to `default`)\n\n- **Limited to:**\n\n  - `<template>`\n  - [components](https://it.vuejs.org/guide/components/slots.html#scoped-slots) (for a lone default slot with props)\n\n- **Example**\n\n  ```html\n  <!-- Named slots -->\n  <BaseLayout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    <template v-slot:default>\n      Default slot content\n    </template>\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </BaseLayout>\n\n  <!-- Named slot that receives props -->\n  <InfiniteScroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </InfiniteScroll>\n\n  <!-- Default slot that receive props, with destructuring -->\n  <Mouse v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </Mouse>\n  ```\n\n- **See also**\n  - [Components - Slots](https://it.vuejs.org/guide/components/slots.html)"
      },
      "references": "api/built-in-directives.html#v-slot"
    },
    {
      "name": "v-pre",
      "valueSet": "v",
      "description": {
        "kind": "markdown",
        "value": "Skip compilation for this element and all its children.\n\n- **Does not expect expression**\n\n- **Details**\n\n  Inside the element with `v-pre`, all Vue template syntax will be preserved and rendered as-is. The most common use case of this is displaying raw mustache tags.\n\n- **Example**\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n  ```"
      },
      "references": "api/built-in-directives.html#v-pre"
    },
    {
      "name": "v-once",
      "valueSet": "v",
      "description": {
        "kind": "markdown",
        "value": "Render the element and component once only, and skip future updates.\n\n- **Does not expect expression**\n\n- **Details**\n\n  On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.\n\n  ```html\n  <!-- single element -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- the element have children -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- component -->\n  <MyComponent v-once :comment=\"msg\"></MyComponent>\n  <!-- `v-for` directive -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n  Since 3.2, you can also memoize part of the template with invalidation conditions using [`v-memo`](#v-memo).\n\n- **See also**\n  - [Data Binding Syntax - interpolations](https://it.vuejs.org/guide/essentials/template-syntax.html#text-interpolation)\n  - [v-memo](#v-memo)"
      },
      "references": "api/built-in-directives.html#v-once"
    },
    {
      "name": "v-memo",
      "description": {
        "kind": "markdown",
        "value": "- **Expects:** `any[]`\n\n- **Details**\n\n  Memoize a sub-tree of the template. Can be used on both elements and components. The directive expects a fixed-length array of dependency values to compare for the memoization. If every value in the array was the same as last render, then updates for the entire sub-tree will be skipped. For example:\n\n  ```html\n  <div v-memo=\"[valueA, valueB]\">\n    ...\n  </div>\n  ```\n\n  When the component re-renders, if both `valueA` and `valueB` remain the same, all updates for this `<div>` and its children will be skipped. In fact, even the Virtual DOM VNode creation will also be skipped since the memoized copy of the sub-tree can be reused.\n\n  It is important to specify the memoization array correctly, otherwise we may skip updates that should indeed be applied. `v-memo` with an empty dependency array (`v-memo=\"[]\"`) would be functionally equivalent to `v-once`.\n\n  **Usage with `v-for`**\n\n  `v-memo` is provided solely for micro optimizations in performance-critical scenarios and should be rarely needed. The most common case where this may prove helpful is when rendering large `v-for` lists (where `length > 1000`):\n\n  ```html\n  <div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id === selected]\">\n    <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>\n    <p>...more child nodes</p>\n  </div>\n  ```\n\n  When the component's `selected` state changes, a large amount of VNodes will be created even though most of the items remained exactly the same. The `v-memo` usage here is essentially saying \"only update this item if it went from non-selected to selected, or the other way around\". This allows every unaffected item to reuse its previous VNode and skip diffing entirely. Note we don't need to include `item.id` in the memo dependency array here since Vue automatically infers it from the item's `:key`.\n\n  :::warning\n  When using `v-memo` with `v-for`, make sure they are used on the same element. **`v-memo` does not work inside `v-for`.**\n  :::\n\n  `v-memo` can also be used on components to manually prevent unwanted updates in certain edge cases where the child component update check has been de-optimized. But again, it is the developer's responsibility to specify correct dependency arrays to avoid skipping necessary updates.\n\n- **See also**\n  - [v-once](#v-once)"
      },
      "references": "api/built-in-directives.html#v-memo"
    },
    {
      "name": "v-cloak",
      "valueSet": "v",
      "description": {
        "kind": "markdown",
        "value": "Used to hide un-compiled template until it is ready.\n\n- **Does not expect expression**\n\n- **Details**\n\n  **This directive is only needed in no-build-step setups.**\n\n  When using in-DOM templates, there can be a \"flash of un-compiled templates\": the user may see raw mustache tags until the mounted component replaces them with rendered content.\n\n  `v-cloak` will remain on the element until the associated component instance is mounted. Combined with CSS rules such as `[v-cloak] { display: none }`, it can be used to hide the raw templates until the component is ready.\n\n- **Example**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  The `<div>` will not be visible until the compilation is done."
      },
      "references": "api/built-in-directives.html#v-cloak"
    },
    {
      "name": "key",
      "description": {
        "kind": "markdown",
        "value": "The `key` special attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify vnodes when diffing the new list of nodes against the old list.\n\n- **Expects:** `number | string | symbol`\n\n- **Details**\n\n  Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed / destroyed.\n\n  Children of the same common parent must have **unique keys**. Duplicate keys will cause render errors.\n\n  The most common use case is combined with `v-for`:\n\n  ```html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:\n\n  - Properly trigger lifecycle hooks of a component\n  - Trigger transitions\n\n  For example:\n\n  ```html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  When `text` changes, the `<span>` will always be replaced instead of patched, so a transition will be triggered.\n\n- **See also** [Guide - List Rendering - Maintaining State with `key`](https://it.vuejs.org/guide/essentials/list.html#maintaining-state-with-key)"
      },
      "references": "api/built-in-special-attributes.html#key"
    },
    {
      "name": "ref",
      "description": {
        "kind": "markdown",
        "value": "Denotes a [template ref](https://it.vuejs.org/guide/essentials/template-refs.html).\n\n- **Expects:** `string | Function`\n\n- **Details**\n\n  `ref` is used to register a reference to an element or a child component.\n\n  In Options API, the reference will be registered under the component's `this.$refs` object:\n\n  ```html\n  <!-- stored as this.$refs.p -->\n  <p ref=\"p\">hello</p>\n  ```\n\n  In Composition API, the reference will be stored in a ref with matching name:\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const p = ref()\n  </script>\n\n  <template>\n    <p ref=\"p\">hello</p>\n  </template>\n  ```\n\n  If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be the child component instance.\n\n  Alternatively `ref` can accept a function value which provides full control over where to store the reference:\n\n  ```html\n  <ChildComponent :ref=\"(el) => child = el\" />\n  ```\n\n  An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you must wait until the component is mounted before accessing them.\n\n  `this.$refs` is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\n- **See also**\n  - [Guide - Template Refs](https://it.vuejs.org/guide/essentials/template-refs.html)\n  - [Guide - Typing Template Refs](https://it.vuejs.org/guide/typescript/composition-api.html#typing-template-refs) <sup class=\"vt-badge ts\" />\n  - [Guide - Typing Component Template Refs](https://it.vuejs.org/guide/typescript/composition-api.html#typing-component-template-refs) <sup class=\"vt-badge ts\" />"
      },
      "references": "api/built-in-special-attributes.html#ref"
    },
    {
      "name": "is",
      "description": {
        "kind": "markdown",
        "value": "Used for binding [dynamic components](https://it.vuejs.org/guide/essentials/component-basics.html#dynamic-components).\n\n- **Expects:** `string | Component`\n\n- **Usage on native elements** <sup class=\"vt-badge\">3.1+</sup>\n\n  When the `is` attribute is used on a native HTML element, it will be interpreted as a [Customized built-in element](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example), which is a native web platform feature.\n\n  There is, however, a use case where you may need Vue to replace a native element with a Vue component, as explained in [DOM Template Parsing Caveats](https://it.vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats). You can prefix the value of the `is` attribute with `vue:` so that Vue will render the element as a Vue component instead:\n\n  ```html\n  <table>\n    <tr is=\"vue:my-row-component\"></tr>\n  </table>\n  ```\n\n- **See also**\n\n  - [Built-in Special Element - `<component>`](https://it.vuejs.org/api/built-in-special-elements.html#component)\n  - [Dynamic Components](https://it.vuejs.org/guide/essentials/component-basics.html#dynamic-components)"
      },
      "references": "api/built-in-special-attributes.html#is"
    }
  ]
}