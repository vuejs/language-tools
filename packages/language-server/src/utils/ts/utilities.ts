import { flatMap, last, map, createGetCanonicalFileName, flatten, sort, compareStringsCaseSensitive, findIndex, getStringComparer, every, indexOfAnyCharCode } from "./core";
import { getNormalizedPathComponents, removeTrailingDirectorySeparator, directorySeparator, normalizePath, combinePaths, fileExtensionIsOneOf, isRootedDiskPath, containsPath, hasExtension, getDirectoryPath } from "./path";
import { CharacterCodes } from "./types";

// KLUDGE: Don't assume one 'node_modules' links to another. More likely a single directory inside the node_modules is the symlink.
// ALso, don't assume that an `@foo` directory is linked. More likely the contents of that are linked.

// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.
// It may be inefficient (we could just match (/[-[\]{}()*+?.,\\^$|#\s]/g), but this is future
// proof.
const reservedCharacterPattern = /[^\w\s\/]/g;

const wildcardCharCodes = [CharacterCodes.asterisk, CharacterCodes.question];

const commonPackageFolders: readonly string[] = ["node_modules", "bower_components", "jspm_packages"];

const implicitExcludePathRegexPattern = `(?!(${commonPackageFolders.join("|")})(/|$))`;

interface WildcardMatcher {
	singleAsteriskRegexFragment: string;
	doubleAsteriskRegexFragment: string;
	replaceWildcardCharacter: (match: string) => string;
}

const filesMatcher: WildcardMatcher = {
	/**
	 * Matches any single directory segment unless it is the last segment and a .min.js file
	 * Breakdown:
	 *  [^./]                   # matches everything up to the first . character (excluding directory separators)
	 *  (\\.(?!min\\.js$))?     # matches . characters but not if they are part of the .min.js file extension
	 */
	singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*",
	/**
	 * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
	 * files or directories, does not match subdirectories that start with a . character
	 */
	doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
	replaceWildcardCharacter: match => replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment)
};

const directoriesMatcher: WildcardMatcher = {
	singleAsteriskRegexFragment: "[^/]*",
	/**
	 * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
	 * files or directories, does not match subdirectories that start with a . character
	 */
	doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
	replaceWildcardCharacter: match => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)
};

const excludeMatcher: WildcardMatcher = {
	singleAsteriskRegexFragment: "[^/]*",
	doubleAsteriskRegexFragment: "(/.+?)?",
	replaceWildcardCharacter: match => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)
};

const wildcardMatchers = {
	files: filesMatcher,
	directories: directoriesMatcher,
	exclude: excludeMatcher
};

function getRegularExpressionForWildcard(specs: readonly string[] | undefined, basePath: string, usage: "files" | "directories" | "exclude"): string | undefined {
	const patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
	if (!patterns || !patterns.length) {
		return undefined;
	}

	const pattern = patterns.map(pattern => `(${pattern})`).join("|");
	// If excluding, match "foo/bar/baz...", but if including, only allow "foo".
	const terminator = usage === "exclude" ? "($|/)" : "$";
	return `^(${pattern})${terminator}`;
}

function getRegularExpressionsForWildcards(specs: readonly string[] | undefined, basePath: string, usage: "files" | "directories" | "exclude"): readonly string[] | undefined {
	if (specs === undefined || specs.length === 0) {
		return undefined;
	}

	return flatMap(specs, spec =>
		spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]));
}

/**
 * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
 * and does not contain any glob characters itself.
 */
function isImplicitGlob(lastPathComponent: string): boolean {
	return !/[.*?]/.test(lastPathComponent);
}

function getSubPatternFromSpec(spec: string, basePath: string, usage: "files" | "directories" | "exclude", { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter }: WildcardMatcher): string | undefined {
	let subpattern = "";
	let hasWrittenComponent = false;
	const components = getNormalizedPathComponents(spec, basePath);
	const lastComponent = last(components);
	if (usage !== "exclude" && lastComponent === "**") {
		return undefined;
	}

	// getNormalizedPathComponents includes the separator for the root component.
	// We need to remove to create our regex correctly.
	components[0] = removeTrailingDirectorySeparator(components[0]);

	if (isImplicitGlob(lastComponent)) {
		components.push("**", "*");
	}

	let optionalCount = 0;
	for (let component of components) {
		if (component === "**") {
			subpattern += doubleAsteriskRegexFragment;
		}
		else {
			if (usage === "directories") {
				subpattern += "(";
				optionalCount++;
			}

			if (hasWrittenComponent) {
				subpattern += directorySeparator;
			}

			if (usage !== "exclude") {
				let componentPattern = "";
				// The * and ? wildcards should not match directories or files that start with . if they
				// appear first in a component. Dotted directories and files can be included explicitly
				// like so: **/.*/.*
				if (component.charCodeAt(0) === CharacterCodes.asterisk) {
					componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?";
					component = component.substr(1);
				}
				else if (component.charCodeAt(0) === CharacterCodes.question) {
					componentPattern += "[^./]";
					component = component.substr(1);
				}

				componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);

				// Patterns should not include subfolders like node_modules unless they are
				// explicitly included as part of the path.
				//
				// As an optimization, if the component pattern is the same as the component,
				// then there definitely were no wildcard characters and we do not need to
				// add the exclusion pattern.
				if (componentPattern !== component) {
					subpattern += implicitExcludePathRegexPattern;
				}

				subpattern += componentPattern;
			}
			else {
				subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
			}
		}

		hasWrittenComponent = true;
	}

	while (optionalCount > 0) {
		subpattern += ")?";
		optionalCount--;
	}

	return subpattern;
}

function replaceWildcardCharacter(match: string, singleAsteriskRegexFragment: string) {
	return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
}

interface FileSystemEntries {
	readonly files: readonly string[];
	readonly directories: readonly string[];
}

interface FileMatcherPatterns {
	/** One pattern for each "include" spec. */
	includeFilePatterns: readonly string[] | undefined;
	/** One pattern matching one of any of the "include" specs. */
	includeFilePattern: string | undefined;
	includeDirectoryPattern: string | undefined;
	excludePattern: string | undefined;
	basePaths: readonly string[];
}

/** @param path directory of the tsconfig.json */
function getFileMatcherPatterns(path: string, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string): FileMatcherPatterns {
	path = normalizePath(path);
	currentDirectory = normalizePath(currentDirectory);
	const absolutePath = combinePaths(currentDirectory, path);

	return {
		includeFilePatterns: map(getRegularExpressionsForWildcards(includes, absolutePath, "files"), pattern => `^${pattern}$`),
		includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
		includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
		excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
		basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)
	};
}

function getRegexFromPattern(pattern: string, useCaseSensitiveFileNames: boolean): RegExp {
	return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
}

/** @param path directory of the tsconfig.json */
export function matchFiles(path: string, extensions: readonly string[] | undefined, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string, depth: number | undefined, getFileSystemEntries: (path: string) => FileSystemEntries, realpath: (path: string) => string): string[] {
	path = normalizePath(path);
	currentDirectory = normalizePath(currentDirectory);

	const patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);

	const includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map(pattern => getRegexFromPattern(pattern, useCaseSensitiveFileNames));
	const includeDirectoryRegex = patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
	const excludeRegex = patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);

	// Associate an array of results with each include regex. This keeps results in order of the "include" order.
	// If there are no "includes", then just put everything in results[0].
	const results: string[][] = includeFileRegexes ? includeFileRegexes.map(() => []) : [[]];
	const visited = new Map<string, true>();
	const toCanonical = createGetCanonicalFileName(useCaseSensitiveFileNames);
	for (const basePath of patterns.basePaths) {
		visitDirectory(basePath, combinePaths(currentDirectory, basePath), depth);
	}

	return flatten(results);

	function visitDirectory(path: string, absolutePath: string, depth: number | undefined) {
		const canonicalPath = toCanonical(realpath(absolutePath));
		if (visited.has(canonicalPath)) return;
		visited.set(canonicalPath, true);
		const { files, directories } = getFileSystemEntries(path);

		for (const current of sort<string>(files, compareStringsCaseSensitive)) {
			const name = combinePaths(path, current);
			const absoluteName = combinePaths(absolutePath, current);
			if (extensions && !fileExtensionIsOneOf(name, extensions)) continue;
			if (excludeRegex && excludeRegex.test(absoluteName)) continue;
			if (!includeFileRegexes) {
				results[0].push(name);
			}
			else {
				const includeIndex = findIndex(includeFileRegexes, re => re.test(absoluteName));
				if (includeIndex !== -1) {
					results[includeIndex].push(name);
				}
			}
		}

		if (depth !== undefined) {
			depth--;
			if (depth === 0) {
				return;
			}
		}

		for (const current of sort<string>(directories, compareStringsCaseSensitive)) {
			const name = combinePaths(path, current);
			const absoluteName = combinePaths(absolutePath, current);
			if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &&
				(!excludeRegex || !excludeRegex.test(absoluteName))) {
				visitDirectory(name, absoluteName, depth);
			}
		}
	}
}

/**
 * Computes the unique non-wildcard base paths amongst the provided include patterns.
 */
function getBasePaths(path: string, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean): string[] {
	// Storage for our results in the form of literal paths (e.g. the paths as written by the user).
	const basePaths: string[] = [path];

	if (includes) {
		// Storage for literal base paths amongst the include patterns.
		const includeBasePaths: string[] = [];
		for (const include of includes) {
			// We also need to check the relative paths by converting them to absolute and normalizing
			// in case they escape the base path (e.g "..\somedirectory")
			const absolute: string = isRootedDiskPath(include) ? include : normalizePath(combinePaths(path, include));
			// Append the literal and canonical candidate base paths.
			includeBasePaths.push(getIncludeBasePath(absolute));
		}

		// Sort the offsets array using either the literal or canonical path representations.
		includeBasePaths.sort(getStringComparer(!useCaseSensitiveFileNames));

		// Iterate over each include base path and include unique base paths that are not a
		// subpath of an existing base path
		for (const includeBasePath of includeBasePaths) {
			if (every(basePaths, basePath => !containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames))) {
				basePaths.push(includeBasePath);
			}
		}
	}

	return basePaths;
}

function getIncludeBasePath(absolute: string): string {
	const wildcardOffset = indexOfAnyCharCode(absolute, wildcardCharCodes);
	if (wildcardOffset < 0) {
		// No "*" or "?" in the path
		return !hasExtension(absolute)
			? absolute
			: removeTrailingDirectorySeparator(getDirectoryPath(absolute));
	}
	return absolute.substring(0, absolute.lastIndexOf(directorySeparator, wildcardOffset));
}
